# 书籍介绍

**JavaScript从入门到精通（微课视频版）（第2版） web前端开发网页设计丛书**

https://item.jd.com/12558421.html

- 出版社： [中国水利水电出版社](https://book.jd.com/publish/中国水利水电出版社_1.html)
- ISBN：9787517076568
- 版次：2
- 商品编码：12558421
- 品牌：[中国水利水电出版社](https://www.jd.com/pinpai/1-1713-447808.html)
- 包装：平装
- 开本：16开
- 出版时间：2019-09-01
- 用纸：胶版纸
- 页数：576
- 字数：1044000

# 第2章: 基本语法

转义序列

变量作用域 
	test2

变量污染
	test2

数字
	test3
	test8
	test9

undefined
	test4

严格模式
	通过浏览器测试不出来

严格模式的执行限制
	在严格模式下，this的值为undefined，所以"!this"为true。
	禁止在函数内部遍历调用栈
	禁止删除变量
		test4
	禁止删除变量
		test11

# 第3章: 运算符和表达式

## 3.1 运算符

3.1.5/test.html

```
//【示例2】在下面代码中，变量a在参与运算的过程中，其值不断被改写，很显然这个过程干扰了程序的正常运行结果。
var a = 1;
a = (a++)+(++a)-(a++)-(++a);
console.log(a);	//返回-4
```

## 3.2 算术运算

### 3.2.1 加法运算

```
console.log(Infinity + Infinity); 	// Infinity与 Infinity相加，结果是Infinity
console.log(( - Infinity) + ( - Infinity)); 	//负Infinity相加，结果是负Infinity
console.log(( - Infinity) + Infinity); 	//正负Infinity相加，结果是NaN
console.log(3.0 + "" + 4.3)	//先连接，再连接，返回"34.3"，3.0转换为字符串为3
```

### 3.2.2 减法运算

 ```
console.log(Infinity - Infinity);	// Infinity与Infinity相减，结果是NaN
console.log(( - Infinity) - ( - Infinity)); 	//负Infinity相减，结果是NaN
console.log(( - Infinity) - Infinity); 	//正负Infinity相减，结果是-Infinity

 ```

### 3.2.3 乘法运算



```
console.log(Infinity * ( - n)); 	// Infinity与任意非0负数相乘，结果都是-Infinity 
console.log(Infinity * 0);	// Infinity与0相乘，结果是NaN
```

### 3.2.4 除法运算

```
console.log(Infinity / n);	//Infinity被任意数字除，结果是Infinity或-Infinity，符号由第二个操作数的符号决定
console.log(Infinity / Infinity);	//返回NaN
console.log(n / 0);	//0除一个非无穷大的数字，结果是Infinity或-Infinity，符号由第二个操作数的符号决定
console.log(n / -0); 	//返回-Infinity ,解释同上
```

### 3.2.5 求余运算

```
console.log(Infinity % n);	//返回NaN
console.log(Infinity % Infinity);	//返回NaN
console.log(n % Infinity);	//返回5
console.log(n % 0);	//返回NaN
console.log(Infinity % 0);	//返回NaN
```

### 3.2.6 求反运算

## 3.3 逻辑运算

### 3.3.1 逻辑与运算

```
//	对象被转换为布尔值时为true。例如，一个空对象与一个布尔值进行逻辑与运算。
console.log(typeof({} && true))	//返回第二个操作数的值true
console.log(typeof(true && {}))	//返回第二个操作数的值{}
```

### 3.3.2 逻辑或运算

### 3.3.3 逻辑非运算

```
//【示例2】如果对于操作数执行两个逻辑非运算操作，就相当于把操作数转换为布尔值。
console.log(!0);	//返回true
console.log(!!0);	//返回false 
```

## 3.4 关系运算

### 3.4.1 大小比较

```
console.log("a">3);	//返回false，字符a被强制转换为NaN
```

### 3.4.2 相等与全等

```
console.log("1" == 1)	//返回true。字符串被转换为数字
console.log(true == 1)	//返回true。true被转换为1
console.log(undefined == null)	//返回true
console.log(NaN == NaN)	//返回false
console.log(NaN != NaN)	//返回true

console.log("1" === 1)	//返回false
console.log(null === undefined)	//返回false

//【示例5】对于复合型对象，主要比较引用的地址，不比较对象的值。
var a = new String("abcd")	//定义字符串"abcd"对象
var b = new String("abcd")	//定义字符串"abcd"对象
console.log(a === b);	//返回false
console.log(a == b);	//返回false

//【示例6】对于简单的值，只要类型相同，值相等，它们就是全等，不考虑表达式运算的过程变化，也不用考虑变量的引用地址。
var a = "1" + 1; 
var b = "11" ; 
console.log(a === b);	//返回true

```

## 3.5 赋值运算

```
//【示例2】在下面复杂的表达式中，逻辑与左侧的操作数是一个赋值表达式，右侧的操作数也是一个赋值表达式。
// 但是左侧赋的是一个简单值，右侧是把一个函数赋值给变量b。
// 在逻辑与运算中，左侧的赋值并没有真正的复制给变量a，当逻辑与运算执行右侧的表达式时，该表达式是把一个函数赋值给变量b，然后利用小括号运算符调用这个函数，返回变量a的值，结果并没有返回变量a的值为6，而是undefined。
var a;	//定义变量a
console.log(a = 6 && (b = function(){	//逻辑与运算表达式
      return a;	//返回变量a的值
   })()
);	//结果返回undefined
```

## 3.6 对象操作运算

### 3.6.1 归属检测

- in
- instanceof

### 3.6.2 删除属性

```
c = 1;	//初始化变量c，没有使用var语句声明
console.log(delete c);	//返回true，说明删除成功
var b = 1;	//使用var语句声明并初始化变量
console.log(delete b);	//返回false，说明不允许删除
console.log(delete Object.constructor); 	//返回true，说明部分内部成员可以被删除

//【示例2】如果删除不存在的对象成员，或者非对象成员、数组元素、变量时，则返回true，所以使用delete运算符时，要注意区分成功删除与无效操作。
var a ={};	//定义对象a
console.log(delete a);	//返回false，说明不允许删除
console.log(delete a.z);	//返回true，说明不存在该属性
console.log(delete b);	//返回true，说明不存在该变量
```

## 3.7 位运算

注意二进制的取反运算

```javascript
console.log(~12);	//返回值-13
```

## 3.8 其他运算

条件运算

```javascript
var a;
typeof a != "undefined" ?  a = a  :  a = 0 ;	//检测变量a是否赋值，否则设置默认值
(typeof a != "undefined") && (a = a) || (a = 0);	//逻辑表达式
```

逗号运算符

```javascript
// 在下面代码中，变量a的值是逗号运算之后，通过第二个操作数c=2的执行结果赋值得到。第一个操作数的执行结果没有返回，但是这个表达式被执行了。
a = (b=1,c=2);	//连续执行和赋值 a=2 b=1 c=2
```

void运算符

```javascript
//【示例1】在下面代码中，使用void运算符让表达式返回undefined。
var a = b = c = 2;	//定义并初始化变量的值
d = void (a -= (b *= (c += 5)));	//执行void运算符，并把返回值赋予给变量d
console.log(a);	//返回-12
console.log(b);	//返回14
console.log(c);	//返回7
console.log(d);	//返回undefined

//【示例2】在下面两行代码中，由于第一行代码没有使用小括号运算符，则void运算符优先执行，返回值undefined再与1执行减法运算，所以返回值为NaN。在第二行代码中由于使用小括号运算符明确void的操作数，减法运算符先被执行，然后再执行void运算，最后返回值是undefined。
console.log(void 2 - 1);	//返回NaN
console.log(void (2 - 1));	//返回undefined

//【示例3】void运算符也能像函数一样使用，如void(0)也是合法的。在特殊环境下一些复杂的语句可能不方便使用void运算符，而必须使用void函数。
console.log( void(i=0));	//返回undefined
console.log( void(i=0, i++));	//返回undefined
```

## 3.9 表达式

表达式优化

```javascript
if(( 6 <= age && age < 18) || 65 <= age ){  }
```

# 第4章: 语句和控制结构

## 4.1 语句

```javascript
var a = b = 1;
a
++
b

console.log(a);			//1
console.log(b);			//2
```

with语句

```
with(o=document.getElementsByTagName("input")){
    o[0].value = 0;
    o[1].value = 1;
    o[2].value = 3;
}
```

## 4.2 分支语句

if

```javascript
if (){
}
else if (){
}
else {}
```

switch

```javascript
var id = 1;
switch ( id ) {
    case 1:	//空匹配, case子句省略语句之后, 当匹配时候, 不管下一个case条件是否满足, 都会继续执行下一个case自居的语句
    case 2:
        console.log( "VIP会员" );	//打印这个
        break;
    case 3:
        console.log( "管理员" );
        break;
    default:
        console.log( "游客" );
}

```

default

```javascript
var id = 1;
switch ( id ) {
    default:										//及时写在前面, 也是先匹配case语句
        console.log( "游客" );
        break;	
    case 1:
        console.log( "普通会员" );	//打印 普通会员
        break;
    case 2:
        console.log( "VIP会员" );
        break;
    case 3:
        console.log( "管理员" );
        break;
}
```

```javascript
// 打印结果, 游客 普通会员 VIP会员
// 先检测case表达式的值, 由于case表达式的值都不匹配, 则跳到default子句执行, 然后继续执行 case 1 和 case 2子句, 但是最后不会返回default语句再重复执行
var id = 3;
switch ( id ) {
    default:
        console.log( "游客" );	 		// 控制台打印1
    case 1:
        console.log( "普通会员" );	// 控制台打印2
    case 2:
        console.log( "VIP会员" );		// 控制台打印3
}
```

 ## 4.3 循环结构

```javascript
for(var i = 0 in document){
    document.write("document."+i+"="+document[i] +"<br />");
}
```

```javascript
Array.prototype.x = "x";	//自定义数组对象的继承属性
var a = [1,2,3];	//定义数组对象，并赋值
a.y = "y";	//定义数组对象的额外属性
for(var i = 0; i < a.length ; i ++ )	//遍历数组对象a
	document.write( i + "：" +  a[i] + "<br />");
// 结果
// 0：1
// 1：2
// 2：3
```



```javascript
Array.prototype.x = "x";	//自定义数组对象的继承属性
var a = [1,2,3];	//定义数组对象，并赋值
a.y = "y";	//定义数组对象的额外属性
for(var i in a){	//遍历数组对象a
	document.write( i+"：" +  a[i] + "<br />");
}
// 结果
// 0：1
// 1：2
// 2：3
// y：y
// x：x
```

## 4.4 流程控制

- break
- continue

 ## 4.5 异常处理

```javascript
try{
    1=1; 					// 制作语法错误
}
catch(error){ 						// 捕获错误
    console.log(error.name); 			// 错误类型
    console.log(error.message); 			// 错误信息
  	throw new Error("再次抛出异常");
}
finally{						// 清除处理
   console.log("1=1");					// 提示代码
}
```

这个示例代码在运行的时候有些错误

## 4.6 案例实战

杨辉三角

# 操作字符串

## 5.1 字符串操作基础

### 字符串定义

```javascript
var s1 = ""
var s2 = ''
console.log( typeof s2 ); 	// 返回string，说明是值类型字符串

//【示例5】下面代码使用new运算符调用String()构造函数，将创建一个字符串型对象。
var s5 = new String()
console.log( typeof s5 ); 	// 返回object，说明是引用型对象

//【示例7】String()也可以作为普通函数使用，把参数转换为字符串类型的值返回。
var s7 = String( 123456 ); 	// 包装字符串, 注意这里没有new
console.log( typeof s7 );	// 返回string，说明是简单的值

//【示例8】String()允许传入多个参数，但是仅处理第一个参数，并把它转换为字符串返回。
var s8 = String( 1, 2, 3, 4, 5, 6 ); 	// 带有多个参数
console.log( s8 ); 	// 返回字符串"1"
console.log( typeof s8 ); 	// 返回string，数值被转换为字符串

//【示例9】下面变量n在构造函数内经过多次计算之后，最后值递增为5。
var n = 1; 	// 初始化变量
var s9 = new String( ++ n, ++ n, ++ n, ++ n); // 字符串构造处理
console.log( s9 ); 	// 返回2
console.log( n ); 	// 返回5
console.log( typeof s9 ); 	// 返回object，说明是引用类型对象
console.log( typeof n ); 	// 返回number，说明是数值类型
```

### 字符串的值

```javascript
s.toString()
s.valueof()
```

### 字符串的长度

```javascript
s.length
```

### 字符串连接

```javascript
var s1 = "abc";
var s2 = "def";
var s3 = s1 + s2; 	//s3 = "abcdef"
var s4 = s1.concat( "d", "e", "f" );  // s4 = "abcdef"
var a = ["a", "b", "c", "d", "e", "f"]
var s5 = a.join("") // s5 = "abcdef"
```

### 字符串查找

```javascript
var s = "http://www.wowoo.com/index.html"
var c = s.charAt(0)
var i1 = s.indexOf("w");					
var i2 = s.indexOf("w", 10);				// 从第10开始找
var i3 = s.lastIndexOf( "o" );
var i4 = s.lastIndexOf( "o", 17);	// 从第17往回找
var n = s.search( "//" );					// n=5
var a1 = s.match( /w/g ); 	// 全局匹配所有字符w, 返回数组  ["w", "w", "w", "w", "w"]

//【示例8】下面代码使用match()方法匹配URL字符串中所有点号字符。
var a2 = s.match( /(\.).*(\.).*(\.)/ ); 	// 执行一次匹配检索
console.log( a2.length ); 	// 返回4，说明返回的是一个包含4个元素的数组
console.log( a2[0] ); 	// 返回字符串"".wowoo.com/index."
console.log( a2[1] ); 	// 返回第一个字符.（点号），由第一个子表达式匹配
console.log( a2[2] ); 	// 返回第二个字符.（点号），由第二个子表达式匹配
console.log( a2[3] ); 	// 返回第三个字符.（点号），由第三个子表达式匹配
```

### 字符串截取

- slice 抽取一个子串
- substr 抽取一个子串, ECMAScript不再建议使用这个方法
- substring 返回字符串的一个子串

```javascript
var s = "http://www.wowoo.com/index.html"
var a = s.substr(7, 13)	//从序列号7开始, 截取13个字符, "www.wowoo.com"
var b = s.substr(21)			//从序列号21开始, 到结束, "index.html"

// substring(开始下标, 结束下标)
// slice(开始下标, 结束下标)
var c = s.substring(7, 20); //截取字符串[7, 20), "www.wowoo.com"
var d = s.slice(7, 20); 		//从序列号7开始, 到序列号20, 不包括序列号20, "www.wowoo.com"

// 如果 开始下表 > 结束下标
// substring方法能够在执行之前交换参数
// slice方法返回空字符串
var e = s.substring(20, 7); //截取字符串[7, 20), "www.wowoo.com"
var f = s.slice(20, 7); 		//f = "", 这里substring和slice就有了区别

// 如果参数值为负值
// substring方法视作无效, 返回空字符串
// slice方法能够解释为从右侧开始定位
var g = s.substring(-4, -1); //g=""
var h = s.slice(-4, -1); 		//h="htm"
```

关于index的解释如下

| h    | t    | t    | p    | :    | /    | /    | ...... | n    | d    | x    | .    | h    | t    | m    | l    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2    | 3    | 4    | 5    | 6    | ...... | -8   | -7   | -6   | -5   | -4   | -3   | -2   | -1   |

### 字符串替换

```javascript
var s = "http://www.wowoo.com/index.html"
// 第一个参数 /html/ 是正则表达式对象
var a = s.replace( /html/, "jsp" ); 	// 把字符串html替换为jsp
var b = s.replace("html", "jsp" ); 	// 把字符串html替换为jsp

//【示例2】下面代码在使用replace()方法时，灵活使用替换函数修改匹配字符串。
var s = "http://www.mysite.cn/index.html";
function f( x ){ 	// 替换文本函数
		console.log("x = ", x)	//x =  http://www.mysite.cn/index.html
    return x.substring( x.lastIndexOf(".")+1, x.length - 1 ) // 获取扩展名部分字符串
}
var c = s.replace( /(html)/, f(s)); 	// 调用函数指定替换文本操作

//【示例3】在replace()方法中约定了一个特殊的字符（$），这个美元符号如果附加一个序号就表示对正则表达式中匹配的子表达式存储的字符串引用。
var s = "JavaScript";
var d = s.replace( /(Java)(Script)/, "$2-$1");	// 交换位置

// $& 表示 与正则表达式想匹配的子字符串
//【示例4】重复字符串。
var s = "JavaScript";
var e = s.replace( /.*/, "$&$&");	// 返回字符串" JavaScriptJavaScript "

// $` 美元符号+切换技能键 位于匹配字符串左侧的文本
// var f = s.replace( /Script/, "$&") 返回的是 "JavaScript"
//【示例5】对匹配文本左侧的文本完全引用。
var s = "JavaScript";
var f = s.replace( /Script/, "$& != $`");	// 返回字符串"JavaScript != Java"

//【示例6】对匹配文本右侧的文本完全引用。
var s = "JavaScript";
var g = s.replace( /Java/, "$&$' is ");	// 返回字符串"JavaScript is Script"
```

### 字符串大小转换

```javascript
var s = "JavaScript";
var a = s.toUpperCase();	// 返回字符串"JAVASCRIPT"
var b = s.toLowerCase();
```

### 字符串比较

### 字符串与数组转换

```javascript
//【示例1】如果参数为空字符串，则split()方法能够按单个字符进行分切，然后返回与字符串等长的数组。
var s = "JavaScript";
var a = s.split("");	// 按字符空隙分割, 长度10, ["J", "a", "v", "a", "S", "c", "r", "i", "p", "t"]
var b = s.split();	// 空分割, 没有对字符串进行分割, 长度1, ["JavaScript"]
var c = s.split("",4); 	// 按顺序从左到有，仅分切4个元素的数组, 返回数组[J,a,v ,a]

var s = "a2b3c4d5e678f12g";
var d = s.split(/\d+/);	// 把匹配的数字为分隔符来切分字符串, 返回数组[a,b,c ,d,e, f,g]

var s = "122a2b3c4d5e678f12g";	// 字符串左侧有匹配的数字
var e = s.split(/\d+/);	// 把匹配的数字作为分隔符来切分字符串, 返回数组[,a,b,c ,d,e, f,g]

//【示例6】如果想使返回的数组包括分隔符或分隔符的一个或多个部分，可以使用带子表达式的正则表达式来实现。
// 这个例子比较难理解
var s = "aa2bb3cc4dd5e678f12g";
var a = s.split(/(\d)/); 	// 使用小括号包含数字分隔符, 返回数组[aa,2,bb,3,cc,4,dd,5,e,6,,7,,8,f,1,,2,g]
```

### 字符串格式化

大部分没有ECMAScript支持, 请谨慎使用

```javascript
//【示例】下面示例演示了如何使用上面字符串方法为字符串定义格式化显示属性。
var s = "abcdef";
document.write(s.bold());	// 定义加粗显示字符串"abcdef"
document.write(s.link("http://www.mysite.cn/"));//为字符串"abcdef"定义超链接
document.write(s.italics());	// 定义斜体显示字符串"abcdef"
document.write(s.fontcolor("red"));	// 定义字符串"abcdef"红色显示
```

### 清楚两侧空字符

```javascript
var s = "    abc def     \r\n  ";
s = s.trim();
```

### unicode编码和解码

- escape()和unescape()方法, 使用转义序列替换某些字符来对字符串进行编码, 不推荐使用
- encodeURI()和decodeURI()方法, 通过转义某些字符对URI进行编码
- encodeURI()和decodeURI()方法, 通过转义某些字符对URI的组件进行编码

```javascript
//【示例2】下面代码使用unescape()方法解码被escape()方法编码的字符串。
var s = "JavaScript中国";
s = escape(s); 	// Unicode编码
console.log(s); 	// 返回字符串"JavaScript%u4E2D%u56FD"
s = unescape(s); 	// Unicode解码
console.log(s); 	// 返回字符串"JavaScript中国"

//【示例6】下面代码比较URL字符串被encodeURIComponent()方法编码前后的比较。
var s = "http://www.mysite.cn/navi/search.asp?keyword=URI";
var a = encodeURI(s);	// "http://www.mysite.cn/navi/search.asp?keyword=URI"
var b = encodeURIComponent(s); //"http%3A%2F%2Fwww.mysite.cn%2Fnavi%2Fsearch.asp%3Fkeyword%3DURI"
// 转义用于分割uri的各个部分的标点符号
```

### base64编码和解码

base64是一种编码方法, 可以将任意字符(包括二进制字符流)转成可打印字符

base64方法不能够操作非ASCII字符

- btoa
- atob

```javascript
function b64Encode(str) {
    return btoa(encodeURIComponent(str));
}
function b64Decode(str) {
    return decodeURIComponent(atob(str));
}
var b = b64Encode('JavaScript从入门到精通');
var a = b64Decode(b);
```

## 5.2 案例实战



# 第6章: 正则表达式

## 6.1 正则表达式对象

### 定义正则表达式

```javascript
//1. 构造正则表达式

//【示例1】下面示例使用RegExp构造函数定义了一个简单的正则表达式，匹配模式为字符＂a＂，没有设置第二个参数，所以这个正则表达式只能够匹配字符串中第一个小写字母a，后面的字母a将无法被匹配到。
var r = new RegExp("a");	//构造最简单的正则表达式
var s = "javascript!=JAVA";	//定义字符串直接量
var a = s.match(r);	//调用正则表达式执行匹配操作，返回匹配的数组
console.log(a);	//返回数组["a"]
console.log(a.index);	//返回值为1，匹配的下标位置

//【示例2】如果希望匹配字符串中所有的字母a，且不区分大小写，则可以在第2个参数中设置g和i修饰词。
var r = new RegExp("a","gi");	//设置匹配模式为全局匹配，且不区分大小写
var s = "javascript!=JAVA";	//字符串直接量
var a = s.match(r);	//匹配查找
console.log(a);	//返回数组["a","a","A","A"]

//【示例5】RegExp()也可以作为普通函数使用，这时与使用new运算符调用构造函数功能相同。不过如果函数的参数是正则表达式，那么它仅返回正则表达式，而不再创建一个新的RegExp对象。
var a = new RegExp("\\b\\w","gi");	//构造正则表达式对象
var b = new RegExp(a);	//对正则表达式对象进行再封装
var c = RegExp(a);	//返回正则表达式直接量
console.log(a.constructor == RegExp);	//返回true
console.log(b.constructor == RegExp);	//返回true
console.log(c.constructor == RegExp);	//返回true

//2. 正则表达式直接量

//【示例6】下面示例定义一个正则表达式直接量，然后进行调用。
var r = /\b\w/gi;
var s = "javascript JAVA";
var a = s.match(r);	//直接调用正则表达式直接量
console.log(a);	//返回数组["j", "J"]

//【示例7】在RegExp()构造函数中可以传递变量，而在正则表达式直接量中是不允许的。
var r = new RegExp("a"+ s + "b","g");	//动态创建正则表达式
var r = /"a"+ s + "b"/g;	//错误的用法
```

### 执行匹配

```javascript
var s = "JavaScript";	//测试使用的字符串直接量
var r = /\w/g;	//匹配模式
while((a = r.exec(s)) ){	//循环执行匹配操作
    console.log("匹配文本 = " +  a[0] + "    a.index = " + a.index  + "    r.lastIndex = " +  r.lastIndex); 
	//显示每次匹配操作后返回的数组信息
}
```

控制台结果如下

```
匹配文本 = J    a.index = 0    r.lastIndex = 1
匹配文本 = a    a.index = 1    r.lastIndex = 2
匹配文本 = v    a.index = 2    r.lastIndex = 3
匹配文本 = a    a.index = 3    r.lastIndex = 4
匹配文本 = S    a.index = 4    r.lastIndex = 5
匹配文本 = c    a.index = 5    r.lastIndex = 6
匹配文本 = r    a.index = 6    r.lastIndex = 7
匹配文本 = i    a.index = 7    r.lastIndex = 8
匹配文本 = p    a.index = 8    r.lastIndex = 9
匹配文本 = t    a.index = 9    r.lastIndex = 10
```

### 执行检测

```javascript
var s = "BlaaaBlaaablaoooBlass";	//测试字符串
var r = /Bla/gi;	//匹配模式
while(r.test(s)){	//循环执行匹配检测，如果true，则继续验证
	console.log("匹配文本 = " +  RegExp.lastMatch + "   r.lastIndex = " +  r.lastIndex); 
	//利用RegExp静态属性显示当前匹配的信息
}
```

### 编译正则表达式

使用正则表达式的compile方法, 能够重新编译正则表达式. 这样在脚本执行过程中可以动态修改正则表达式的匹配模式

```javascript
var s = "JavaScript";	//测试字符串
var r = /\w/g;	//匹配模式
while(r.test(s)){	//循环执行匹配验证，如果返回true，则连续执行验证
	if(r.lastIndex == 3){
		r.compile(/[A-Z]/g);
    // r.compile("[A-Z]","g");	//也可以写成这种模式
		r.lastIndex = 3;//设置下一次匹配的起始位置, 如果不设置的话, 又会从头开始匹配
	}
    console.log("匹配文本 = " +  RegExp.lastMatch + "   r.lastIndex = " +  r.lastIndex); 
}
```

### 正则表达式属性

```javascript
var s = "JavaScript";	//测试字符串
var r = /\w/g;	//匹配模式
console.log("r.global = " + r.global);	//返回true, 检测RegExp对象是否具有标志g 
console.log("r.ignoreCase = " + r.ignoreCase);	//返回false, 检测RegExp对象是否具有标志i
console.log("r.multiline = " + r.multiline);	//返回false, 检测RegExp对象是否具有标志m
console.log("r.source = " + r.source);	//返回\w，返回正则表达式的字符模式源码
console.log("r.lastIndex = " + r.lastIndex);	//返回0, 返回执行下一次匹配的下标位置
r.exec(s);
console.log("r.lastIndex = " + r.lastIndex);	//返回1
```

### RegExp静态属性

静态属性记录了当前脚本中最新正则表达式匹配的详细信息

这些比较难, 平时使用也少

```javascript
var s = "JavaScript,not JavaScript";
var r = /(Java)Script/gi;
var a = r.exec(s);	//执行匹配操作
// input/$_ 返回当前所作用的字符串
console.log(RegExp.input);	//返回字符串"JavaScript,not JavaScript"
console.log(RegExp.$_);	//返回字符串"JavaScript,not JavaScript"
// leftContext/$`
console.log(RegExp.leftContext); 	//返回空字符串，左侧没有内容
console.log(RegExp["$`"]);	//返回空字符串
// rightContext/$'
console.log(RegExp.rightContext);	//返回字符串",not JavaScript"
console.log(RegExp["$'"]);	//返回字符串",not JavaScript"
// lastMatch/$& 最后模式匹配的字符串
console.log(RegExp.lastMatch);	//返回字符串"JavaScript "
console.log(RegExp["$&"]);	//返回字符串"JavaScript "
// lastParen/$+
console.log(RegExp.lastParen);	//返回字符串"Java"
console.log(RegExp["$+"]);	//返回字符串"Script"
```



## 6.2 字符模式

### 描述字符

```javascript
//【示例1】下面使用ASCII编码定义正则表达式直接量。
var r = /\x61/;	//以ASCII编码匹配字母a

//【示例2】除了十六进制外，还可以直接使用八进制数值表示字符。
var r = /\141/;	//141是字母a的ASCII编码的八进制值

//【示例3】ASCII编码只能够匹配有限的单字节字符，使用Unicode编码可以表示双字节字符。Unicode编码方式：“\u”前缀加上4位十六进制值。
var r = /\u0061/;	//以Unicode编码匹配字母a

//在RegExp()构造函数中使用元字符时，应使用双斜杠。
var r = new RegExp("\\u0061");

```

### 描述字符范围

```javascript
//如果匹配任意ASCII字符：
var r = /[\u0000-\u00ff]/g;
```

### 选择匹配

```javascript
var r = /\'|\"|\<|\>/gi;	//过滤敏感字符的正则表达式
```

### 重复匹配

```javascript
var r = /go?gle/g;	//匹配前一项字符o0次或1次
var r = /go{0,1}gle/g;	//匹配前一项字符o0次或1次
var r = /go{3}gle/g;	//匹配前一项字符o重复显示3次
var r = /go{3,5}gle/g;	//匹配第4个到第6个之间的单词
var r = /go*gle/g;	//匹配所有的单词
var r = /go{0,}gle/g;	//匹配所有的单词
var r = /go+gle/g;	//匹配的单词中字符＂o＂至少出现1次
var r = /go{1,}gle/g;	//匹配的单词中字符＂o＂至少出现1次
```

### 惰性匹配

在重复类两次后面添加问号(?)

```javascript
var s ="<html><head><title></title></head><body></body></html>";
var r = /<.*?>/
var a = s.match(r);	//返回单元素数组["<html>"]
var r = /<.*>?/
var a = s.match(r); 
	//返回单元素数组["<html><head><title></title></head> <body></body></html>"]
```

### 边界量词

```javascript
var s = "how are you";
var r = /\w+$/;		//匹配最后一个单词
var r = /^\w+/;		//匹配第一个单词
```

### 声明量词

```javascript
var s = "one:1;two=2";
// 1. 正向声明
// 指定匹配模式后面的字符必须被匹配, 但又不返回这些字符
// 匹配模式(?=匹配条件)
// 只有在\w*所能够匹配的字符后面跟随一个等号字符, 才能够执行\w*匹配
var r = /\w*(?==)/;	//使用正向声明，指定执行匹配必须满足的条件
var a = s.match(r);	//返回数组["two"]
// 2. 反向声明
// 指定匹配模式后面的字符都不必被匹配
// 匹配模式(?!匹配条件)
// 只有在\w*所能够匹配的字符后面不跟随一个等号字符, 才能够执行\w*匹配
var r = /\w*(?!=)/;	//使用反向声明，指定执行匹配不必满足的条件
var a = s.match(r);	//返回数组["one"]
```

### 子表达式

```javascript
var s ="ab=21,bc=45,cd=43";
var r = /(\w+)=(\d*)/g;
while(a = r.exec(s)){
	console.log(a);	//每个a返回类似数组["ab=21" , "ab","21"]
}
```

### 反向引用

在字符模式中, 后面的字符可以引用前面的子表达式

\数字

\1 引用第1个子表达式

\2 引用第2个子表达式

### 禁止引用

反向引用会占用系统资源

实现方法: 在左括号前加上一个问号和冒号

```javascript
var s1 = "abc";
var r = /(?:\w*?)|(?:\d*?)/;	//非引用型分组
```

# 第7章: 使用数组

## 7.1 定义数组

```javascript
//【示例2】传递多个值，可以创建一个实数组。
var a = new Array(1,true,"string",[1,2],{x:1,y:2});	//实数组
console.log(a);

//【示例3】传递一个数值参数，可以定义数组的长度，即包含元素的个数。
var a = new Array(5);	//指定长度的数组
console.log(a[0]);	//返回undefined，说明参数为长度值

var a = [];	//空数组
var a = [1,true,"0",[1,0],{x:1,y:0}];	//包含具体元素的数组

var a = [	//定义二维数组
    [1.1, 1.2],
    [2.1, 2.2]
];
```

### 空位数组

```javascript
// 直接量定义
var a = [1, , 2];
a.length;	//返回3

var a = [1, 2, ];
a.length;	//返回2

//delete删除, 长度不改
var a = [1, 2, 3];
delete a[1];
console.log( a[1] );	// undefined
console.log( a.length ); 	// 3

//如果使用for语句和length属性遍历数组，空元素都可以被读取，空元素返回值为undefined。
//注意, 这里的长度是3, 不是4
var a = [, , ,];
for(var i =0; i<a.length;i++)
    console.log( a[i]); 	//返回3个undefined

//空元素与元素的值为undefined是两个不同的概念，虽然空元素的返回值也是undefined。但是，使用forEach()方法、for/in语句、以及Object.keys()方法进行遍历时，空元素都会被跳过，但是值为undefined元素，能够正常被迭代。
var a = [, , undefined,];
for (var i in a) {
    console.log(i);	// 返回2，仅读取了第3个元素
}
console.log(a.length); 	// 返回3，包含3个元素
```



### 关联数组



```javascript
var a = [];	//声明数组
a[false] = false; 
a[true] = true; 
console.log( a["false"] );//返回值false，
console.log( a["true"] );//返回值true
```

### 伪类数组

```javascript
var obj = {
	0 : 0,
	1 : 1,
	2 : 2,
	length : 3			
};
console.log( obj["2"] );
```

## 7.2 访问数组

```javascript
//【示例3】设计有两个变量，交换它们的值
//利用数组就可以这样设计：
var a = 10, b = 20;	//变量初始化
a = [b, b = a][0];	//通过数组快速交换数据, 最主要原因是变量放到数组里是传值
```

### 数组长度

```javascript
var a = [1,2,3];	//声明数组直接量
a.length = 5;	//增长数组长度
a.length = 2;	//缩短数组长度
console.log(a[2]);	//返回undefined，说明该元素的值已经丢失
```

### for迭代

```javascript
var a = [1, 2, ,,,,,,true,,,,,,, "a",,,,,,,,,,,,,,,4,,,,,56,,,,,,"b"];	//定义数组
var num=0;
for( var i = 0; i < a.length ; i ++ ){	//遍历数组
    num++;	//计数器
}
console.log( num ); 	//返回42，说明循环了42次

// for/in执行效率高
// for/in会跳过空元素
// 对于超长数组, 建议使用for/in循环
var num=0;
for( var i in a ){	//遍历数组
    num++;	//计数器
}
console.log( num ); 	//返回7，说明循环了7次

```



### forEach迭代

```javascript
array.forEach(callbackfn[, thisArg])
// callbackfn 最多可以接受3个参数的函数
// callbackfn函数中的this可引用的对象, 如果省略， 则this值为underfined
// 数组调用顺序采用升序索引， 数组中空元素不会调用
// 参数1 数组值
// 参数2 数组序号
// 参数3 整个数组值
```



```javascript
function f(value, index, array) {
	console.log(  "a[" + index +  "] = " + value )
}
var a = ['a', 'b', 'c'];
a.forEach(f);

var obj = {
    f1: function(value, index, array) {
      console.log(  "a[" + index +  "] = " + value );
      array[index] = this.f2(value);
    },
    f2: function(x) { return x * x }
};
var a = [12, 26, 36];
a.forEach(obj.f1, obj);
console.log(a);
```

### keys迭代

keys 仅能迭代本地,可枚举的属性

getOwnPropertyNames 可以迭代所有本地属性

```javascript
var o = {a:"A", b:"B",c:"C"}
console.log(Object.keys(o));
console.log(Object.getOwnPropertyNames(o) ); // ["a", "b", "c"]

var a = ["A", "B", "C"]
console.log(Object.keys(a));		//["0", "1", "2"]
console.log(Object.getOwnPropertyNames(a) );	//["0", "1", "2", "length"], 多了一个length
```



## 7.3 操作数组

### 栈操作

栈: FILO first in last out

基本操作

- push
- pop

### 队列操作

队列: FIFO first in first out

基本操作

- shift 出队
- unshift 入队

```javascript
//【示例1】使用unshift()分批插入元素与一次性插入元素结果是不同的。
var a = [0];	//定义数组
a.unshift(1,2);	//一次性增加两个元素
console.log(a);	//返回[1,2,0]
var a = [0];
a.unshift(1);	//增加元素1
a.unshift(2);	//增加元素2
console.log(a);	//返回[2,1,0]

//【示例2】将pop()与unshift()方法结合，或者将push()与shift()方法结合使，可以模拟队列操作。下面的示例利用队列模式把数组元素的所有值放大10倍。
var a = [1,2,3,4,5];	//定义数组
// 注意: 这个过程中a的值是一只变化的, 但是for循环使用的a是调用之前的不变值
for(var i in a){	//遍历数组
    var t = a.pop();	//尾部弹出
    a.unshift(t*10);	//头部推入，把推进的值放大10倍
}
console.log(a);	//返回[10,20,30,40,50]
```

```javascript
//【示例3】下面示例是一个经典的编程游戏。有一群猴子排成一圈，按1、2、3…n依次编号。然后从第1只开始数，数到第m只，则把它踢出圈，从它后面再开始数，再数到第m只，也把它踢出去，依此类推，直到只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n，输出最后那个大王的编号。
//n表示猴子个数，m表示踢出位置
function f(n, m){
    //将猴子编号并放入数组
    var arr = [];
    for(i = 1; i < n+1; i++){
        arr.push(i);
    }
    //当数组内只剩下一个猴子时跳出数组
    while(arr.length > 1){
        for(var i=0;  i< m-1 ;  i++){	//定义轮转的次数
            arr.push(arr.shift());	//队列操作，完成猴子的轮转
        }
        arr.shift();	//踢出第m个猴子
    }
    return arr;	//返回包含最后一个猴子的数组
}
console.log( f(5,3));	//编号为4的猴子胜出
```

### 删除操作

```javascript
//【示例1】使用delete运算符能删除数组元素，删除后的元素为空位元素，删除数组的length不变。
var a = [1, 2, true, "a", "b"];	//定义数组
delete a[0];	//删除指定下标的元素
console.log( a);	//返回[, 2, true, "a", "b"]

//【示例2】使用length属性可以删除尾部一个或多个元素，甚至可以清空数组。删除元素之后，数组的length也动态保持更新。
var a = [1, 2, true, "a", "b"];	//定义数组
a.length = 3 ;	//删除尾部2个元素
console.log( a);	//返回[1, 2, true]


var a = [1,2,3,4,5];	//定义数组
a.splice(1,2)	//执行删除操作
console.log(a);	//返回[1, 4, 5]


var a = [1,2,3,4,5];	//定义数组
a.splice(2);	//从第三个元素开始执行删除
console.log(a);	//返回[1, 2]
```

### 添加元素

```javascript
//concat()是一个比较特殊的数组元素添加方法。它采用粘连的方式把参数添加到数组中。
var a = [1,2,3,4,5];	//定义数组
var b = a.concat(6,7,8);	//为数组a连接3个元素
console.log(b);	//返回[1,2,3,4,5,6,7,8]

var b = a.concat([1,2,3],[4,5]);	//连接数组
console.log(b.length);	//返回10，说明参数数组被打散了


var b = a.concat([[1,2],3],[4,5]);	//连接数组
console.log(b.length);	//返回9，说明数组[1,2]没有被打散

var a = [1,2,3,4,5];	//定义数组
a.splice(1,0,3,4,5)	//执行插入操作
console.log(a);	//返回[1,3,4,5,2,3,4,5]
```

### 截取元素

使用splice()方法

```javascript
// splice()方法执行的返回值是被删除的子数组。
var a = [1,2,3,4,5];	//定义数组
var b = a.splice(2);	//从第三个元素开始执行删除
console.log(b);	//被删除的子数组是[1, 2]

var b = a.splice(2,0);	//不执行删除操作

// 当第一个参数值大于length属性值时，被视为在数组尾部执行操作，因此删除无效，但是可以在尾部插入多个指定元素。
var a = [1,2,3,4,5];	//定义数组
var b = a.splice(6,2,2,3);	//起始值大于length属性值
console.log(a);	//返回[1, 2, 3, 4, 5, 2, 3]

// 参数取负值问题。如果第一个参数为负值，则按绝对值从数组右侧开始向左侧定位。如果第2个参数为负值，则被视为0。
var a = [1,2,3,4,5];	//定义数组
var b = a.splice(-2,-2,2,3);	//第一、二个参数都为负值
console.log(a);	//返回[1, 2, 3, 2, 3, 4, 5]
```

使用slice()方法

```javascript
var a = [1,2,3,4,5];	//定义数组
var b = a.slice(2,5);	//截取第三个元素到第六个元素前的所有元素
console.log(b);	//返回[3, 4, 5]
```

### 数组排序

```javascript
//1. 使用reverse()方法
var a = [1,2,3,4,5];	//定义数组
a.reverse();	//颠倒数组顺序

//2. 使用sort()方法
var a = ["a","e","d","b","c"];	//定义数组
a.sort();	//按字母顺序对元素进行排序

//在下面示例中，将根据排序函数比较数组中每个元素的大小，并按从小到大的顺序执行排序。
function f( a, b ){	//排序函数
    return ( a - b )	//返回比较参数
}
var a = [3, 1, 2, 4, 5, 7, 6, 8, 0, 9];	//定义数组
a.sort(f);	//根据数字大小由小到大进行排序
```

### 数组转换

toString

```javascript
var a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];	//定义数组
var s = a.toString();	//把数组转换为字符串

var a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];	//定义数组
var b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];	//定义数组
var s = a + b;	//数组连接操作
console.log( s ); //返回"1, 2, 3, 4, 5, 6, 7, 8, 9, 01, 2, 3, 4, 5, 6, 7, 8, 9, 0"
console.log( typeof s );	//返回字符串string，说明是字符串类型

var a = [[1, [2, 3], [4, 5]], [6, [7, [8, 9], 0]]];	//定义多维数组
var s = a.toString();	//把数组转换为字符串
console.log( s );	//返回字符串"1, 2, 3, 4, 5, 6, 7, 8, 9, 0"

```

toLocalString

```javascript
// 下面使用toLocalString()方法读取数组的值。

var a = [1, 2, 3, 4, 5];	//定义数组
var s = a.toLocaleString();	//把数组转换为本地字符串
console.log( s );	//返回字符串"1.00,  2.00 , 3.00 , 4. 00, 5 .00 "
```

join/split

```javascript
//【示例3】下面使用join()方法可以把数组转换为字符串。

var a = [1, 2, 3, 4, 5];	//定义数组
var s = a.join("==");	//指定分隔符
console.log( s );	//返回字符串"1==2== 3==4 ==5"

//【示例4】下面使用split()方法把字符串转换为数组。

var s = "1==2== 3==4 ==5";	//定义字符串
var a = s.split("==");	//分隔字符串为数组
console.log( a );	//返回数组[1, 2, 3, 4, 5]
console.log( a.constructor == Array );	//返回true，说明是数组
```

### 元素定位

- indexOf
- lastIndexOf

### 检测数组

```javascript
var a = [1, 2, 3];
console.log( typeof a ); 	// "object"
console.log( Array.isArray(a) ) ;	// true

var a = [1, 2, 3];
console.log( 2 in a );  	// true
console.log( '2' in a ); 	// true, 由于键名都是字符串, 所以数值2会自动转成字符串
console.log( 4 in a ); 	// false
```

### 遍历元素检测

- every
- some

```javascript
function f(value, index, array) {
    if (value % 2 == 0) return true;
    else  return false;
}
var a = [2, 4, 5, 6, 8];
if (a.every(f)) 
  console.log("都是偶数。");
else 
  console.log("不全为偶数。");

var f = function(value) {
    if (typeof value !== 'number') return false;
    else  return value >= this.min && value <= this.max;
}
var a = [10, 15, 19];
var obj = { min: 10, max: 20 }
if (a.every(f, obj)) console.log ("都在指定范围内。");
else console.log ("部分不在范围内。");

function f(value, index, ar) {
    if (value % 2 == 0) return true;
}
var a = [1, 15, 4, 10, 11, 22];
var evens = a.some(f);
if(evens) console.log("不全是奇数。");
else  console.log("全是奇数。");

```

### 映射数组

```javascript
function f(radius) {
    var area = Math.PI * (radius * radius);
    return area.toFixed(0);
}
var a = [10, 20, 30];
var a1 = a.map(f);
console.log(a1);	//314,1257,2827

var obj = {
    val: 10,
    f: function (value) {
        return value % this.val;
    }
}
var a = [6, 12, 25, 30];
var a1 = a.map(obj.f, obj);
console.log(a1);	//6,2,5,0

function f(value, index, str) {
    return str.substring(index - 1, index + 2);
}
var s = "Thursday";
var a = [].map.call(s, f);
console.log(a);	//Th,Thu,hur,urs,rsd,sda,day,ay
```

### 数组过滤

```javascript
// 示例1
function f(value, index, ar) {
    return true;
}
var a = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];
var a1 = a.filter(f);

// 示例2
var f = function(value) {
    if (typeof value !== 'number')
        return false;
    else 
        return value >= this.min && value <= this.max ;
}

var a = [6, 12, "15", 16, "the", -12];
var obj = { min: 10, max: 20 }
var r = a.filter(f, obj);

// 示例3
function f(value, index, ar) {
    if (index == 0)
        return true;
    else
        return ar[index - 1] === " ";
}
var a = "The quick brown fox jumps over the lazy dog."; 
var subset = [].filter.call(a, f); 
```

### 数组汇总

- reducce

  ```javascript
  array.reduce(callbackfn[, initialVal])
  // initialVal 用作初始值来启动累积, 第一次调用callbackfn函数会将此值作为参数而非数组值提供
  // 如果提供initialVal, reduce方法会对数组中的每个元素调用一次callbackfn函数
  // 如果未提供initialVal, reduce方法会对从数组中的第2个元素开始的每个元素调用一次callbackfn函数
  ```

- reduceRight

```javascript
//【示例1】下面示例演示将数组值连接成字符串，各个值用“::”分隔开。由于未向reduce 方法提供初始值，第一次调用回调函数时会将“abc”作为 previousValue 参数并将“def”作为currentValue 参数。
function f(pre, curr) {
    return pre + "::" + curr;
}
var a = ["abc", "def", 123, 456];
var r = a.reduce(f);
console.log(r);	//abc::def::123::456

//【示例2】下面示例向数组中添加值。 currentIndex和array 参数用于回调函数。
// i index
// array 整个数组
function f1(pre, curr, i, array) {
    var e = (array.length - 1) - i;
    var d = curr * Math.pow(10, e);
    return pre + d;
}
var a = [4, 1, 2, 5];
var r = a.reduce(f1, 0);
console.log (r);	//4125

//【示例3】下面示例获取一个数组，该数组仅包含另一个数组中的介于 1 和 10 之间值， 提供给reduce 方法的初始值是一个空数组。
function f2(pre, curr) {
    var next;
    if (curr >= 1 && curr <= 10)
        next = pre.concat(curr);
    else
        next = pre;
    return next;
}
var a1 = [20, 1, -5, 6, 50, 3];
var a = new Array();
var r = a1.reduce(f2, a);
console.log(r);//1,6,3

//【示例4】下面示例使用reduceRight方法，以"::"为分隔符，从右到左把数组元素的值连接在一起。
function f (pre, curr) {
    return pre + "::" + curr;
}
var a = ["abc", "def", 123, 456];
var r = a.reduceRight(f);
console.log(r);	//456::123::def::abc
```

# 第8章: 使用函数

## 8.1 定义函数

### 声明函数

```javascript
function funName(){}	//空函数
function(){}	//匿名空函数
```

### 构造函数

使用Function()构造函数可以快速生成函数, 具体用法如下

```javascript
var funcName = new Function(p1, p2, ..., pn, body)
```

这个方法不常用

```javascript
//【示例3】在Function()构造函数参数中，p1~pn是参数名称的列表，即p1不仅能代表一个参数，它可以是一个逗号隔开的参数列表。下面的定义方法是等价的：
var f = new Function("a", "b", "c", "return a+b+c")
var f = new Function("a, b, c", "return a+b+c")
var f = new Function("a,b", "c", "return a+b+c")
```

### 函数直接量

函数直接量也叫做匿名函数

### 定义嵌套函数

## 8.2 调用函数

### 函数调用

```javascript
//【示例3】设计递归调用函数，即在函数内调用自身，这样可以反复调用，但最终返回的都是函数自身。
function f(){	//定义函数
    return f;	//返回函数自身
}
console.log(f()()()()()()()()()()()());	//返回函数自身
```

### 使用call和apply调用

call和apply是Function的原型方法, 他们能够将特定函数当作一个方法绑定到指定对象上, 并进行调用

```javascript
function.call(thisobj, args...)
function.apply(thisobj, [args])
```

thisobj表示绑定对象, 即this指代的对象

args表示要传递的参数

call方法可以接收多个参数列表

apply方法只能接受一个数组或者伪类数组, 数组元素将作为参数列表传递给被调用的函数

```javascript
//【示例1】下面示例使用call动态调用函数f，并传入参数值3和4，返回运算值。
function f(x,y){	//定义求和函数
    return x+y;
}
console.log( f.call(null, 3, 4));	//返回7

function f(x,y){	//定义求和函数
    return x+y;
}
console.log( f.apply(null, [3, 4] ));	//返回7

function max(){	//求最大值函数
    var m = Number.NEGATIVE_INFINITY; 		
		//声明一个负无穷大的数值
    for( var i = 0; i < arguments.length; i ++ ){		 
				//遍历函数所有的实参
        if( arguments[i] > m )	//如果实参值大于变量m，
        m = arguments[i];	//则把该实参值赋值给m
    }
    return m;	//返回最大值
}
var a = [23, 45, 2, 46, 62, 45, 56, 63]; 			
//声明并初始化数组
var m = max.apply( Object, a ); 	
//把函数max绑定为Object对象的方法，并动态调用

function f() {
    return "函数f";
}
var obj = {};
f.call( obj );	//把函数f绑定为obj对象的方法,当函数动态调用之后, 这个对象的临时方法也就不存在了。这样使用的意义在哪？
console.log( obj.f() );	//再次调用该方法，则返回编译错误
```

### 使用new调用

```javascript
function f(x,y){	//定义求和函数
    console.log("x = " + x + ", y = " + y );
}
new f(3, 4); //看不出来与直接 f(3, 4)调用的区别
```

## 8.3 函数参数

### 获取参数个数

arguments.length 获取实参个数

arguments.callee.length 获取行参个数

```javascript
function f( a, b){
    if( arguments.length != arguments.callee.length ) 	//如果实参与形参个数不同，则抛出错误
    	throw new Error( "实参和形参不一致" );
    else
      return a - b;
}
console.log( f( 6) );	//抛出异常。调用函数f，传入1个参数
```

## 8.4 函数作用域

- 全局作用域
- 局部作用域/函数作用域



### 执行上下文和活动对象

```javascript
var b = true;
console.log( window.b );	//true
this.window.b = false;
console.log(this.b);	//false
```



### 作用域链



### this和调用对象

javascript函数的作用域是静态的, 但函数的调用却是动态的。

this是一个指针型变量, 它动态引用当前的运行环境。具体来说，就是调用函数的对象。

下面这个示例有点难

```javascript
var x = 1;	//声明全局变量并初始化
var obj = {
    f: function () {	//定义方法f
        console.log(this.x); 	//访问当前运行环境中x属性值
    },
    x: 2, 	//定义属性x，赋值为2
};


(test = obj.f)();	//1
(obj.f = obj.f)();	//1, 这里设置了一个trick, 其实和上面是一样的, obj.f = obj.f 只是一个赋值表达式
(false || obj.f)();	//1
(obj.f, obj.f)();	//1


obj.f();	//2
(obj.f)();	//2
```



### 函数的标识符

在函数结构中, 一般包含如下类型的标识符

- 函数参数
- 局部变量
- 内部函数
- this

这些标识符在函数体内的优先级是

this > 局部变量 > 形参 > arguments > 函数名

```javascript
//【示例6】如果局部变量没有赋值，则会选择形参变量。
function f(x){	//定义普通函数
    var x;	//定义局部变量
    console.log(x);	//显示变量x的值
}
f(5);	//传递参数值为5，返回提示为5

```

## 8.5 闭包

闭包是javascript的重要特性之一，在函数式编程中有着重要的作用。

闭包很重要, 比较难懂, 一定要掌握

## 8.6 函数式运算

### 函数合成

把多个单一参数函数合成一个多参数的函数的运算, 例如

a(x)和b(x)组合成f(a,b,x)

### 函数柯里化

柯里化就是把一个多参数的函数转化为单一参数函数

## 8.7 高阶函数

高阶函数也称作算子(运算符)或泛函。

高阶函数是函数式编程最显著的特征

### 回调函数

将函数作为值传入另一个函数, 当参数函数被调用时, 就称为回调函数, 即异步调用已绑定的函数

### 单例模式

### 实现AOP

AOP面向切面编程

### 函数节流

函数节流就是降低函数被调用的频率

设计思想: 让代码在间断的情况下重复执行

### 分时函数

### 惰性载入函数

惰性载入就是当第1次根据条件执行函数后, 第2次调用函数时, 就不再检测条件, 直接执行函数

### 分支函数

### 偏函数

把一个函数的某些参数先固化， 也就是设置默认值, 返回一个新的函数，在新函数中继续接收剩余参数, 这样调用这个新函数会更简单。

```javascript
//偏函数方法：
var isType=function(type){
     return function(obj){
          return Object.prototype.toString.call(obj)=='[object ' + type+ ']';
     }  
}
var isString = isType("String");
var isFunction = isType("Function");

```

### 泛型函数(uncurry)

```javascript
Function.prototype.uncurry = function() {	//泛型函数
    var self = this;
    return function() {
      	// 使用2个apply函数, 实现逻辑思路的2次翻转
        return Function.prototype.apply.apply(self, arguments);
    }
};

//泛化Array.prototype.push
var push = Array.prototype.push.uncurry();
var obj = {};
push(obj, [3, 4, 5]); 	// 可以把数组转换为类数组
for(var i in obj)
    console.log(i);   // 输出类数组：{0: 3, 1: 4, 2: 5, length: 3}
```

### 类型检测

## 8.8 递归函数

### 尾递归

```javascript
//普通递归函数
//n表示数字
function f( n ){
    return ( n == 1 ) ? 1 : n * f( n - 1 );
}
console.log(f(6));

//尾递归函数
//n表示数字，a表示每次计算的结果
function f( n, a ){
    return( n == 1 ) ? a : f( n - 1, a * n );
}
console.log( f(5 , 1) );
```

### 递归与迭代

在实际应用中, 能不用递归就不用递归, 递归都可以用迭代来代替

```javascript
var fibonacci = function(n) {
    var a=[0,1];	//记录数列的数组，第1、2个元素值确定
    for(var i=2; i<=n; i++){	//从第3个数字开始循环
        a.push( a[i-2] + a[i-1] );	//计算新数字，并推入数组
    }
    return a[n];	//返回指定位数的数列结果
};
console.log(fibonacci(100))	//4181

// 将斐波拉契数列函数封装在一个闭包体内, 然后返回斐波那契数列函数
// 这么些有什么好处呢?
var fibonacci = ( function() {
    var memo = [0, 1];
    var fib = function(n) {
        var result = memo[n];
        if( typeof result !== 'number') {
            result = fib(n - 1) + fib(n - 2);
            memo[n] = result;
        }
        return result;
    };
    return fib;
}());
console.log(fibonacci(100));
```

# 第9章: 使用对象

## 9.1 定义对象

```javascript
// 1. 构造对象
// var objName = new functionName(args)
//【示例】下面示例使用不同类型的构造函数定义各种实例。
var o = new Object();	//定义一个空对象

// 2. 对象直接量
//【示例1】下面代码使用对象直接量定义2个对象。
var o = {	//对象直接量
    a : 1,	//定义属性
    b : true,	//定义属性
    c : function(){	//定义方法
        return 1;
    }
}

// 3. Object.create()
// Object.create(prototype, description)
// prototype 指定原型对象, 可以为null
```





